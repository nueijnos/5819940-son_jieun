# Quick Sorting {Result Image}
**재귀적 방법으로 구현**
![](./quicksort(재귀).PNG)

**반복적 방법으로 구현**
![](./quicksort(반복).PNG)

# 보너스 문제 풀이
![](./B_quicksort1.PNG)
![](./B_quicksort2.PNG)

# 이전 정렬방법(선택, 삽입, 버블, 쉘, 합병)과 성능 비교 설명
| 정렬 | 최선의 경우 | 평균의 경우 | 최악의 경우 | 제자리 정렬 | 안정성 |
|------|-------------|--------------|-------------|-------------|--------|
| 선택 |    O(n²)    |     O(n²)    |     O(n²)    |    가능     | 불안정 |
| 삽입 |     O(n)    |     O(n²)    |     O(n²)    |    가능     |  안정  |
| 버블 |    O(n²)    |     O(n²)    |     O(n²)    |    가능     |  안정  |
|  쉘  |     O(n)    |    O(n¹·⁵)   |    O(n¹·⁵)   |    가능     | 불안정 |
| 합병 |  O(nlogn)   |   O(nlogn)   |   O(nlogn)   |    불가능   |  안정  |
|  퀵  |   O(nlogn)  |   O(nlogn)   |    O(n²)     |    가능     | 불안정 |

퀵 정렬의 시간복잡도 평균적인 경우를 보면 선택 정렬, 삽입 정렬, 버블 정렬의 평균적인 경우(O(n²))보다 월등히 빠른 것을 알 수 있습니다. 또, 쉘 정렬의 평균적인 경우(O(n¹·⁵))보다 빠르고, 합병 정렬과 비교했을 때 평균적인 경우(O(nlogn))와 똑같지만 제자리 정렬이 안되는 합병 정렬과는 달리 퀵 정렬은 제자리 정렬이 가능하고, 추가적인 메모리 공간을 필요로 하지 않기 때문에 대부분의 경우에서 빠른 속도를 보입니다. 
그러나, 퀵 정렬은 쉘 정렬처럼 그룹(*여기서 그룹이란, 쉘 정렬은 gap, 퀵 정렬은 pivot을 말함*)을 어떻게 설정하는지에 따라 성능이 달라진다는 단점을 보이기 때문에 두 정렬 모두 안정적이지 않다는 것을 보여줍니다.

=>퀵 정렬은 기본적으로 불안정한 알고리즘이지만 파티션 구현을 어떻게 하냐에 따라 안정적으로 만들 수 있다.
